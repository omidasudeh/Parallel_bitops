#include <boost/unordered_map.hpp>
#include "mybitops.h"
#include <vector>
#include <unordered_map>
using namespace std;
size_t Log_NUM_THREADS = 9;
unordered_map<int,vector<size_t>*> results; // key:tid, value:pointer to partial result generated by tid
static pthread_barrier_t barrier1;
struct th_arg{
  int tid;
  size_t bitWorkLength;
  vector<size_t>* vec1;
  vector<size_t>* vec2;
  size_t* word_len1;
  size_t* word_len2;
  size_t* preSum1;
  size_t* preSum2;
};
////###################### Bit Operation ###################################


vector<size_t> mybitops::logic_and_ref(vector<size_t>*( v1),vector<size_t>*( v2), size_t v1begin, size_t  v1end,
                                        size_t v2begin, size_t  v2end ) {
  clock_t t0 = clock();
  
  int ones = 0, zeros = 0;
  vector<size_t> result_vector;
  size_t it1 = v1begin;
  size_t it2 = v2begin;
  size_t word1 = (*v1)[it1];
  size_t word2 = (*v2)[it2];
  //while(it1 != vector1.end() && it2 != vector2.end()) {
  int iters = 0;
  while(it1 <= v1end && it2 <= v2end) {
    iters++;
    
    if(ismyfill(word1) && ismyfill(word2)) {  //both are fill words
      size_t c1 = word1 & 0x3fffffff;         //get the len of fill word
      size_t c2 = word2 & 0x3fffffff;         //get the len of fill word
      size_t isone1 = word1 & 0x40000000;     //check if it is one
      size_t isone2 = word2 & 0x40000000;     //check if it is one

      if(c1 == c2) {
        if(isone1 && isone2) {
          //allZeros = false;
          ones += c1;
          if(zeros > 0) {
            size_t n = 0x80000000 + zeros;
            zeros = 0;
            result_vector.push_back(n);
          }
        } else {
          zeros += c1;
          if(ones > 0) {
            size_t n = 0xc0000000 + ones;
            ones = 0;
            result_vector.push_back(n);
          }
        }
        word1 = (*v1)[++it1];
        word2 = (*v2)[++it2];
      } else if (c1 > c2) {
        if(isone1 && isone2) {
          //allZeros = false;
          ones += c2;
          if(zeros > 0) {
            size_t n = 0x80000000 + zeros;
            zeros = 0;
            result_vector.push_back(n);
          }
        } else {
          zeros += c2;
          if(ones > 0) {
            size_t n = 0xc0000000 + ones;
            ones = 0;
            result_vector.push_back(n);
          }
        }
        if(isone1)
          word1 = 0xc0000000 + (c1 - c2);
        else
          word1 = 0x80000000 + (c1 - c2);
        word2 = (*v2)[++it2];
      } else { //c2 > c1
        if(isone1 && isone2) {
          //allZeros = false;
          ones += c1;
          if(zeros > 0) {
            size_t n = 0x80000000 + zeros;
            zeros = 0;
            result_vector.push_back(n);
          }
        } else {
          zeros += c1;
          if(ones > 0) {
            size_t n = 0xc0000000 + ones;
            ones = 0;
            result_vector.push_back(n);
          }
        }
        if(isone2)
          word2 = 0xc0000000 + (c2 - c1);
        else
          word2 = 0x80000000 + (c2 - c1);
        word1 = (*v1)[++it1];
      }
    } else if(ismyfill(word1) && !ismyfill(word2)) { //one fill, one literal
      size_t c1 = word1 & 0x3fffffff; //lenth
      size_t isone1 = word1 & 0x40000000;  //is one?

      if(isone1) { //if one, depend on literal
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          //allZeros = false;
          ones = 0;
          result_vector.push_back(n);
        }
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          result_vector.push_back(n);
        }
        //if (word2 != 0) //allZeros = false;
        result_vector.push_back(word2);
      } else { //id zero, generate a zero word
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          ones = 0;
          result_vector.push_back(n);
        }
        zeros += 31;
      }
      if(c1 == 31){
        word1 = (*v1)[++it1];
      }
      else {
        if(isone1)
          word1 = 0xc0000000 + (c1 - (size_t)31);
        else
          word1 = 0x80000000 + (c1 - (size_t)31);
      }
      word2 = (*v2)[++it2];
    } else if(!ismyfill(word1) && ismyfill(word2)) { //one literal, one fill
      size_t c2 = word2 & 0x3fffffff; //lenth
      size_t isone2 = word2 & 0x40000000;  //is one?

      if(isone2) { //if one, depend on literal
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          //allZeros = false;
          ones = 0;
          result_vector.push_back(n);
        }
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          result_vector.push_back(n);
        }
        //if (word1 != 0) //allZeros = false;
        result_vector.push_back(word1);
      } else { //id zero, generate a zero word
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          ones = 0;
          result_vector.push_back(n);
        }
        zeros += 31;
      }
      if(c2 == 31)
        word2 = (*v2)[++it2];
      else {
        if(isone2)
          word2 = 0xc0000000 + (c2 - (size_t)31);
        else
          word2 = 0x80000000 + (c2 - (size_t)31);
      }
      word1 = (*v1)[++it1];
    } else { //both are literal words
      size_t num = word1 & word2;
      if(num == 0) {
        zeros += 31;
        if(ones > 0) {
		  //allZeros = false;
          size_t n = 0xc0000000 + ones;
          ones = 0;
          result_vector.push_back(n);
        }
      } else if (num == 0x7fffffff) {
        ones += 31;
        //allZeros = false;
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          result_vector.push_back(n);
        }
      } else {
        if(ones > 0) {
          //allZeros = false;
          size_t n = 0xc0000000 + ones;
          ones = 0;
          result_vector.push_back(n);
        }
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          result_vector.push_back(n);
        }
        //if (num != 0) //allZeros = false;
        result_vector.push_back(num);
      }
      word1 = (*v1)[++it1];
      word2 = (*v2)[++it2];
    }
  }
  if(ones > 0) {
	//allZeros = false;
    size_t n = 0xc0000000 + ones;
    ones = 0;
    result_vector.push_back(n);
  }
  if(zeros > 0) {
    size_t n = 0x80000000 + zeros;
    zeros = 0;
    result_vector.push_back(n);
  }
  clock_t t1 = clock();
  printf("and %u %u %u\n",v1end-v1begin,v2end-v2begin,iters);
  // printf("and_time: %d\n",t1-t0);
	//cout<<vector1.size()<<"  "<<vector1.size()<<" it1"<<it1<<"  it2:"<<it2<<endl;
  return result_vector;
}
vector<size_t> mybitops::compressBitset(const boost::dynamic_bitset<> dbitset) {
  vector<size_t>cvector;
  size_t zeros = 0;
  size_t ones = 0;

  for(unsigned int j=0; j<dbitset.size();) {
    size_t num = 0;
    for(int k=0; k<31; k++) {
      if(j+k >= dbitset.size())
        break;
      num <<= 1;
      if(dbitset[j+k])
        num++;
    }
    if(j+31 >= dbitset.size()) {
      bool isAllZero = true;
      bool isAllOne = true;
      for(unsigned int k= j; k<dbitset.size(); k++) {
        if(dbitset[k] == true)
          isAllZero = false;
        if(dbitset[k] == false)
          isAllOne = false;
      }
      if(isAllZero) {
        zeros += dbitset.size() - j;
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          ones = 0;
          cvector.push_back(n);
        }
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          cvector.push_back(n);
        }
      } else if(isAllOne) {
        ones += dbitset.size() - j;
        if(zeros > 0) {
          size_t n = 0x80000000 + zeros;
          zeros = 0;
          cvector.push_back(n);
        }
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          ones = 0;
          cvector.push_back(n);
        }
      } else {
        if(ones > 0) {
          size_t n = 0xc0000000 + ones;
          ones = 0;
          cvector.push_back(n);
        }
        if(zeros > 0) {
           size_t n = 0x80000000 + zeros;
           zeros = 0;
           cvector.push_back(n);
        }
        cvector.push_back(num);
      }
      break;
    }
    j += 31;
    if(num == 0) {
      zeros += 31;
      if(ones > 0) {
        size_t n = 0xc0000000 + ones;
        ones = 0;
        cvector.push_back(n);
      }
    } else if(num == 0x7fffffff) {
      ones += 31;
      if(zeros > 0) {
        size_t n = 0x80000000 + zeros;
        zeros = 0;
        cvector.push_back(n);
      }
    } else {
      if(ones > 0) {
        size_t n = 0xc0000000 + ones;
        ones = 0;
        cvector.push_back(n);
      }
      if(zeros > 0) {
        size_t n = 0x80000000 + zeros;
        zeros = 0;
        cvector.push_back(n);
      }
      cvector.push_back(num);
    }
  } //end j
  return cvector;
}
boost::dynamic_bitset<> mybitops::uncompressIndex(vector<size_t> cvector, size_t uncompressed_size){
  boost::dynamic_bitset<> bitvector(uncompressed_size);
  unsigned int mybit = 0;//current position
  for(vector<size_t>::iterator it=cvector.begin(); it!=cvector.end(); ++it) {
	  if (mybit >= uncompressed_size) break;
    if(((*it) & 0x80000000) == 0) {//if lit
      int temp = 30;
      if(mybit + 31 > uncompressed_size) {
        temp = uncompressed_size - mybit - 1;
      }
      for(int j=temp; j>=0; j--) {
        size_t mask = (size_t)1 << j;
        if(((*it) & mask) > 0)
          bitvector[mybit] = true;
        mybit++;
        if(mybit >= uncompressed_size)
          break;
      }
    } else {
      size_t c = (*it) & 0x3fffffff;
      if(((*it) & 0x40000000) > 0) {  //if all 1
         for(int j=(int)c; j>0; j--) {
           bitvector[mybit] = true;
           mybit++;
           if(mybit >= uncompressed_size)
             break;
         }
      } else  //if all 0
         mybit += (int)c;
    }
  } //end iterator
  return bitvector;
}

int mybitops::ismyfill(size_t word1) {
  if((word1 & 0x80000000) == 0)
    return 0; // literal word
  else
    return 1; // fill word
}
/*
 * Returns the word type:
 * 0: literal 
 * 1: zeros
 * 2: ones
 */

int mybitops::word_type(size_t word1) {
  if((word1 & 0x80000000) == 0)
    return 0; // literal word
  else{// fill word
	  if((word1 & 0xc0000000) == 0xc0000000)
		return 2;//ones
	  else
		return 1;//zeros
		 
	}
}
size_t myBinarySearch (size_t* arr, size_t l, size_t r, size_t x)
{
  if(x==0)
    return 0;
  if (r >= l)
  {        
    size_t mid = l + (r - l)/2;    
    // If the element is present at the middle 
    // itself
    if (arr[mid] == x)  
      return mid;
    // If element is smaller than mid, then 
    // it can only be present in left subarray
    if (arr[mid] > x) 
      return myBinarySearch(arr, l, mid-1, x);
    // Else the element can only be present
    // in right subarray
    return myBinarySearch(arr, mid+1, r, x);
  }
 
  // We reach here when element is not 
  // present in array
  if(r<0)
    return 0;
  return r;
}
void* thread_kernel(void* args)
{
  clock_t t1 = clock(); // almost 0 cycles up to t2
  
  // 1. unpacking the thread arguments
  th_arg *thread_args = (th_arg *)args;
  int tid = thread_args->tid;
  size_t bitWorkLength = thread_args->bitWorkLength;
   
  vector<size_t>* vec1 = thread_args->vec1;
  vector<size_t>* vec2 = thread_args->vec2;

  size_t vec1_size  = vec1->size();
  size_t vec2_size  = vec2->size();
  
  size_t* word_len1 = thread_args->word_len1;
  size_t* word_len2 = thread_args->word_len2;
  size_t* preSum1 =  thread_args->preSum1;
  size_t* preSum2 =  thread_args->preSum2;
  
  //2. compute the bit working area
  size_t chunk_size = bitWorkLength>>Log_NUM_THREADS;
  // printf("CS: %u\n",bitWorkLength);
  size_t b1 = tid*chunk_size;
  size_t b2 = (tid+1)*chunk_size;

  //3. calc the word working area 
  int w11 = myBinarySearch(preSum1,0,vec1_size-1,b1);
  int w12 = myBinarySearch(preSum1,0,vec1_size-1,b2);
  int w21 = myBinarySearch(preSum2,0,vec2_size-1,b1);
  int w22 = myBinarySearch(preSum2,0,vec2_size-1,b2);
  // printf("tid:%d b1:%u b2:%u w11:%u w12:%u w21:%u w22:%u\n",tid,b1,b2,w11,w12,w21,w22);
  // printf("tid:%d w11:%u w12:%u w21:%u w22:%u\n",tid,w11,w12,w21,w22);
  // pthread_exit(NULL);  

  //4. compute the AND for your area
  //4.1 right alignment
  // TODO: !!!!!!!!!!!!!!!
  
  //4.2 pass my working area to and_op function
  

  //4.3 sequential_and my working area  
  mybitops Bitops;  
  vector<size_t>* myResult = new vector<size_t>;
  clock_t t2 = clock(); // 20000 cycles up to t3

  // *myResult = Bitops.logic_and_ref(vec1,vec2,0,vec1_size-1,0,vec2_size-1); // this is the bottle neck
  *myResult = Bitops.logic_and_ref(vec1,vec2,w11,w12,w21,w22);
  clock_t t3 = clock();
  printf("tid:%u %u %u %u %u\n",tid,t3-t2,t2-t1,w12-w11,w22-w21);

  // results.insert({tid,myResult});
  // pthread_barrier_wait(&barrier1);   
}
vector<size_t> mybitops::parallel_and(vector<size_t> &vector1, vector<size_t> &vector2)
{ 
  //######################## serial preprocessing phase #############################
  //###### 1. calculate size_vector and prefix_sum vector for each input vector 
  clock_t t1 = clock();
  size_t vec1_size = vector1.size();
  size_t vec2_size = vector2.size();
  // cout<<"vec1Size:"<<vec1_size<<" vec2Size:"<<vec2_size<<endl<<endl;

  
  size_t* word_lengths1 = new size_t[vec1_size]; //vector of length of the words
  size_t* prefix_sum1 = new size_t[vec2_size]; // prefix-sum generated form word_lengths1
  size_t pre_sum1 = 0;
  size_t vector1_bit_length = 0;

  for(int i = 0 ; i<vec1_size;i++)
  {
    size_t word = vector1[i];
    int wt = word_type(word);
    size_t word_length = 31;
    if(wt != 0)// if a fill word
      word_length = word & 0x3fffffff;
    word_lengths1[i] = word_length;
    prefix_sum1[i] = pre_sum1+word_length;
    pre_sum1 = prefix_sum1[i];
    vector1_bit_length+=word_length;
  }
  size_t* word_lengths2 = new size_t[vec2_size]; //vector of length of the words
  size_t* prefix_sum2 = new size_t[vec2_size];   // prefix-sum generated form word_lengths1
  size_t pre_sum2 = 0;
  size_t vector2_bit_length = 0;  
  for(int i = 0 ; i<vec2_size;i++)
  {
    size_t word = vector2[i];
    int wt = word_type(word);
    size_t word_length = 31;
    if(wt != 0)// if a fill word
      word_length = word & 0x3fffffff;
    word_lengths2[i] = word_length;
    prefix_sum2[i] = pre_sum2+word_length;
    // printf("%u\n",word_length);
    pre_sum2 = prefix_sum2[i];
    vector2_bit_length+=word_length;  

  }
  size_t min_bit_length = (vector1_bit_length<vector2_bit_length)?vector1_bit_length:vector2_bit_length;
  // printf("here %u %u %u\n",vector1_bit_length,vector2_bit_length,min_bit_length);
  
  clock_t t2 = clock();
  // cout<<"preprocessing time:"<< t2-t1<<endl;
 
  //####### 2. multi threading
  //2.1 instantiate the threads
  pthread_t *threads;
  int NUM_THREADS = 1;
  NUM_THREADS = Log_NUM_THREADS<<NUM_THREADS;
  threads = new pthread_t[NUM_THREADS];
  void *th_status;
  int rc;
	// pthread_barrier_init(&barrier1, NULL, NUM_THREADS);

  //2.2 thread fork
  clock_t t3 = clock();  
  // cout<<"fireing threads"<<endl;
  for(int i=0; i < NUM_THREADS; i++)
  {
    //2.2.1 create the thread arguments
    th_arg *thread_args;
		thread_args = new th_arg;
    thread_args->tid = i;
    thread_args->bitWorkLength = min_bit_length;
    // printf("thread_args->bitWorkLength: %u %u\n",thread_args->bitWorkLength,min_bit_length);
    thread_args->vec1 = &vector1;
    thread_args->vec2 = &vector2;
    
    thread_args->word_len1 = word_lengths1;
    thread_args->word_len2 = word_lengths2;
    thread_args->preSum1 = prefix_sum1;
    thread_args->preSum2 = prefix_sum2;
      

    //2.2.2 fire the threads
    rc = pthread_create(&threads[i], NULL,thread_kernel, (void*) thread_args);
    if(rc)
    {
      cout<<"ERROR; return code from pthread_create() is "<< rc<<endl;
      exit(-1);
    }
  }

  //2.3 thread join
  for(int j=0; j < NUM_THREADS; j++)
  {
    rc = pthread_join( threads[j], NULL); 
    if(rc)
    {
      cout<<"ERROR; return code from pthread_join() is "<< rc<<endl;
      exit(-1);
    }
  }

  clock_t t4 = clock();  
  // cout<<"multi-threading time:"<< t4-t3<<endl;

  clock_t t5 = clock();  
  vector<size_t> result_vector;
  
  
  
  
  /*//3. merge the the partial results
  // result_vector.reserve( A.size() + B.size() ); // preallocate memory
  for(int i = 0;i<NUM_THREADS;i++)
    result_vector.insert(result_vector.end(), results[i]->begin(), results[i]->end());
  
  clock_t t6 = clock();  
  cout<<"merge time:"<< t4-t3<<endl;  */
  return result_vector;
}
